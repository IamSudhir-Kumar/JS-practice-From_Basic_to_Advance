
**Easy:**

1. **Reverse a String:** Write a function that takes a string as input and returns the string reversed. You can iterate through the string in reverse order and build the reversed string character by character.

2. **Palindrome Check:** Create a function that checks if a given string is the same when read forwards and backward (e.g., "racecar" or "level"). You can remove spaces and convert characters to lowercase for a simple solution.

3. **Anagram Check:** Write a function that checks if two strings are anagrams, meaning they contain the same characters, just in a different order. You can use character frequency counts to compare the strings.

4. **Factorial Calculation:** Implement a function to calculate the factorial of a non-negative integer. You can use recursion or a loop to multiply numbers from 1 to n.

5. **Fibonacci Sequence:** Create a function to generate the nth Fibonacci number. You can use recursion or an iterative approach to calculate the Fibonacci sequence.

6. **Find the Largest Element:** Write a function that finds and returns the largest element in an array. You can initialize a variable to track the maximum and iterate through the array to find the largest element.

7. **Array Sum:** Calculate the sum of elements in an array. Initialize a variable to store the sum and iterate through the array, adding each element to the sum.

8. **Unique Characters:** Check if a string has all unique characters. You can create an array or a set to keep track of characters seen and check for duplicates.

9. **Count Vowels and Consonants:** Write a function that counts the number of vowels and consonants in a given string. You can iterate through the characters and classify them as vowels or consonants.

10. **Array Intersection:** Find the intersection of two arrays, which means finding elements that are present in both arrays. You can use loops or set operations to achieve this.

**Intermediate:**

11. **Two Sum Problem:** Given an array of integers and a target sum, find two numbers that add up to the target. Use a hashmap to keep track of visited numbers and their indices.

12. **Merge Intervals:** Merge overlapping intervals in an array. Sort the intervals by their start points and then merge overlapping intervals.

13. **Reverse a Linked List:** Implement a function to reverse a singly linked list. Traverse the list while reversing the pointers.

14. **Binary Search:** Write a binary search algorithm for a sorted array. Divide and conquer by comparing the middle element with the target and adjusting the search range.

15. **Depth-First Search (DFS):** Implement DFS on a graph or a tree. Use recursion to explore as deeply as possible along each branch before backtracking.

16. **Breadth-First Search (BFS):** Implement BFS on a graph or a tree. Use a queue to explore all neighboring nodes before moving to the next level.

17. **Find Missing Number:** Given an array containing n distinct numbers from 0 to n, find the missing number. Calculate the expected sum of all numbers and subtract the actual sum from it.

18. **Longest Substring Without Repeating Characters:** Find the length of the longest substring without repeating characters in a string. Use a sliding window approach.

19. **Rotate an Array:** Rotate an array to the right by k steps. Use array slicing or reverse segments to achieve the rotation.

20. **Two Strings Are One Edit Away:** Check if two strings are one edit away from each other (insert, remove, or replace a character). Compare the strings character by character and keep track of edits.

**Advanced:**

21. **Find the Kth Largest Element:** Find the Kth largest element in an unsorted array using quickselect or a priority queue.

22. **Merge Sort:** Implement the merge sort algorithm, which divides and merges arrays until sorted.

23. **Quick Sort:** Implement the quicksort algorithm, which partitions and recursively sorts elements.

24. **Minimum Window Substring:** Given two strings, find the minimum window in the first string that contains all characters of the second string. Use a sliding window with frequency counters.

25. **Longest Increasing Subsequence:** Find the length of the longest strictly increasing subsequence in an array. Use dynamic programming to track the length of the subsequence.

26. **Maximum Subarray Sum:** Find the contiguous subarray with the largest sum. Use Kadane's algorithm for an efficient solution.

27. **Topological Sorting:** Implement topological sorting for a directed graph to find a valid order of nodes.

28. **Dijkstra's Algorithm:** Implement Dijkstra's algorithm to find the shortest path in a weighted graph, using a priority queue.

29. **Detect a Cycle in a Graph:** Write a function to detect cycles in a directed or undirected graph using depth-first or breadth-first search.

30. **Regular Expression Matching:** Implement a function to match a string with regular expressions (including '*' and '.'). You can use dynamic programming to solve this problem.
